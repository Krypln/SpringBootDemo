package com.nokia.example.Interview;

import com.sun.jndi.cosnaming.IiopUrl;

import java.net.MalformedURLException;

/**
 * Created by YLongYao on 2016/11/10.
 */
public class JVMInterviewIssue {
    /**
     * Java运行时数据区域：
     *      方法区、堆、虚拟机栈、本地方法栈、程序计数器
     *
     *      程序计数器：
     *           每个线程都有一个独立的程序计数器，如果线程正在执行的是一个Java方法，
     *           这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器的值为空
     *           且此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域
     *
     *      Java虚拟机栈：
     *           线程私有，描述的是Java方法执行的内存模型：每个方法执行时都会创建一个栈帧，用于存储局部变量表、
     *           操作数栈、动态链接、方法出口等信息，每个方法从调用到执行的完成的过程，
     *           就对应着一个栈帧从虚拟机栈中入栈到出站的过程；
     *
     *           局部变量表：
     *               存放了编译期可知的各种基本数据类型（boolean、int、long、short、byte、char、float、double）、
     *               对象的引用和returnAddress类型（指向下一条字节码指令的地址）
     *
     *               其中64位的长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个
     *
     *           该区域规定了两种异常状况：
     *                如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
     *                如果虚拟机栈可以动态扩展，如果扩展是无法申请到足够的内存，就会抛出OutOfMemoryError异常
     *
     *      本地方法栈：
     *           本地方法栈与Java虚拟机栈所发挥的作用非常类似，他们之间的区别不过是
     *           虚拟机栈为虚拟机执行Java方法（字节码）服务，本地方法栈为虚拟机使用到Native方法服务
     *           与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常
     *
     *      Java堆：
     *           被所有线程共享，在虚拟机启动时创建，所有的对象实例以及数组都要在堆上分配
     *           Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做‘GC堆’
     *           Java堆可以处理物理上不连续的内存空间中，只要逻辑上连续即可
     *           如果在堆中没有内存完成实例分配，并且堆额无法再扩展时，将会抛出OutOfMemoryError异常
     *
     *      Java方法区：
     *           被所有线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
     *           不需要连续的内存，和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集
     *           该区域的内存回收目标主要针对常量池的回收和对类型的卸载
     *           方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常
     *
     * GC垃圾收集：
     *      永久代（方法区）的垃圾收集主要有两部分内容：回收废弃常量、无用的类
     *          回收废弃常量：与回收Java堆中的对象非常类似
     *          无用的类的回收：
     *              满足以下三个条件才能算是无用的类：
     *                  该类的所有实例都已被回收，即Java堆中不存在该类的任何实例
     *                  加载该类的ClassLoader已经被回收
     *                  该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类
     *
     *           虚拟机可以对满足以上三个条件的无用类进行回收，但是并不是和对象一样不使用就必然回收，
     *           是否回收需要配置参数进行控制
     *
     *          一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize方法做一些重要的清理工作，并且在
     *          下一次垃圾回收动作发生时才会真正回收对象占用的内存
     *
     *      堆的垃圾收集：对象的实例
     *          首先是判断对像是否存活：
     *              引用计数算法：
     *                  给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时计数器就减一
     *                  任何时刻计数器为0的对象就是不可能再被使用的
     *
     *                  优点：实现简单，判定效率高
     *
     *                  缺点：很难解决对象相互循环引用的问题
     *
     *                  目前主流的Java虚拟机里面没有选用引用计数算法来管理内存
     *
     *              可达性分析算法：
     *                  通过一系列的被称为“GC Roots”的对象作为起始点，从这个点开始向下搜索，搜索所走过的路径称为引用链
     *                  当一个对象到GC Roots没有任何引用链相连时，证明这个对象是不可用的
     *
     *                  可以作为GC Roots的对象包括：
     *                      虚拟机栈中引用的对象
     *                      方法区中类静态属性引用的对象
     *                      方法区中常量引用的对象
     *                      本地方法栈中引用的对象
     *
     *               引用分为：
     *                  强引用：默认情况下对象的引用均为强引用（对象的实例没有被其他对象引用，GC时才会被回收）
     *                  软引用：在内存不够用的情况下才会被GC
     *                  弱引用：在GC是一定会被GC回收
     *                  虚引用：用来得知对象是否被GC
     *
     *      垃圾收集算法：
     *           标记-清除算法：
     *               分为标记和清除两个阶段，首先标记出需要回收的对象，在标记完成后统一回收所有被标记的对象
     *               缺点：
     *                   标记和清理两个过程效率都不高
     *                   会产生大量不连续的内存碎片
     *           复制算法：
     *               将内存容量划分为大小相等的两块，每次只使用其中一块，当一块用完就将还存活的对象复制到另一块上
     *               然后在将已使用过的内存空间一次清理掉
     *               优点：实现简单，运行效率高
     *               缺点：内存缩小为原来的一半，在对象存活率较高时就要进行较多的复制操作，效率将变低
     *           标记整理算法：
     *               根据老年代提出的一种算法，标记过程与标记-清理算法一样，但后续不是直接对可回收对象进行清理，
     *               而是让所用存活的对象都向一端移动，然后清理掉端边界以外的内存
     *           分代收集算法：
     *               一般是把Java堆分为新生代和老年代，新生代使用复制算法，老年代使用标记清理或者标记整理算法
     *
     * 虚拟机类加载机制：
     *      虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换、解析、初始化，最终形成可以被虚拟机
     *      直接使用的Java类型（类型的加载、连接、初始化都是在程序运行期间完成）
     *
     *      类的生命周期：加载、连接（验证、准备、解析）、初始化、使用、卸载
     *
     * 类加载器：都继承自抽象类java.lang.ClassLoader
     *      系统提供的类加载器：
     *          启动类加载器（Bootstrap ClassLoader）：负责将存放在JAVA_HOME/lib目录中的，或者被-Xbootclasspath参数
     *              所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中，无法被Java程序直接引用
     *          扩展类加载器（Extention ClassLoader）：负责加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统
     *              变量所指定的路径中的所有类库。开发者可以直接使用扩展类加载器
     *          应用程序类加载器（Application ClassLoader）：这个类加载器是ClassLoader中getSystemClassLoader()方法的
     *              返回值，所以一般也叫系统类加载器，它负责加载用户类路径上所指定的类库
     *
     *      用户自定义的来加载器（User ClassLoader）
     *
     *
     * Java面向对象的SOLID原则：
     *  
     *
     */

    public IiopUrl.Address returnAddressTest() throws MalformedURLException {
        IiopUrl.Address address = new IiopUrl.Address("fds" , true);
        return address;
    }

}
