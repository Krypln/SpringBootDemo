package com.nokia.example.Interview;

/**
 * Created by YLongYao on 2016/10/23.
 */
public class JavaVirtual {
    /**
     * 类加载器：
     *      JVM启动时会调用BootStrap类加载器加载一个初始化类，然后这个类会在main方法调用之前完成链接和初始化
     *      Bootstrap加载器：一般由本地代码实现，负责载入基础的Java API，比如rt.jar
     *      Extension加载器：加载标准Java扩展API中的类，比如security的扩展函数
     *      System加载器：应用的默认类加载器，比如从classpath中加载应用类
     *      用户自定义类加载器：也可以用来加载应用类，运行时重新加载类或者把加载的类分隔为不同的组，如Tomcat
     *
     *      每个类加载器都包含他们所加载的所有类的引用
     *
     * 类加载的五个过程：
     *      加载 、 验证 、 准备 、 解析 、 初始化
     *
     *
     */

    /**
     * 接口和抽象类的区别：
     *      接口中所有方法隐含都是抽象的，抽象类中可由同时包含抽象和非抽象方法
     *      类(包括抽象类)可以实现多个接口，但是只能继承一个抽象类，
     *      抽象类可以继承抽象类和非抽象类，接口支持多继承，一个接口可以继承多个接口
     *      类可以不实现抽象类和接口的所有抽象方法，但是该类必须声明为抽象类
     *      抽象类可以在不提供接口实现方法的情况下实现接口
     *      接口中声明的变量默认时final的，抽象类中可以声明非final变量
     *      接口中成员函数默认时public的，抽象类中可以是private（抽象方法除外）、public或者protected
     *      接口是绝对抽象的，不能被实例化，抽象类也不能被实例化
     *      如果接口和抽象类中的静态方法可以被直接调用
     *
     *      接口中声明的变量默认时public static final，方法默认是public abstract的
     *      接口中可以有main方法，但是有main方法就不能被其他接口继承
     *      抽象方法不能有方法体；
     *
     */
    /**
     * Java虚拟机：
     *      Java虚拟机是一个可执行的Java字节码的虚拟机进程，
     *      Java原文件被编译成能被Java虚拟机执行的字节码文件
     *
     * JVM的生命周期：
     *      启动：启动一个Java程序时，一个JVM实例就产生了，任何一个拥有main函数的class都可以作为JVM实例运行的起点
     *      运行：mian函数作为该程序初始线程时的起点，任何其他线程均有由该线程启动，
     *            JVM中有两种线程：守护线程、非守护线程（main函数属于非守护线程，守护线程通常由JVM自己使用）
     *            Java程序也可以表明自己创建的线程是  守护线程
     *      消亡：当程序中所用非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可使用Runtime类或者System.exit()来退出
     *
     * JVM执行程序的过程：
     *      加载.class文件
     *      管理并分配内存
     *      执行垃圾收集
     *
     * JVM的四大组成部分：
     *      类加载器CLassLoader：加载class文件
     *      运行时数据区Runtime Data Area：
     *      执行引擎Execution Engine：
     *      本地接口Native Interface：调用本地接口
     *
     * JRE：
     *      Java运行时环境，是将要执行Java程序的Java虚拟机，同时包含了执行applet需要的浏览器插件
     * JDK：
     *      Java开发工具包，完整的Java软件开发包，包含了JRE、编译器和其他工具（JavaDoc，Java调试器）
     *
     * 自动装箱：
     *      Java编译器在基本数据类型和其包装类之间做的一个转化，如：把int转成Integer等等，反之则是：自动拆箱
     *      装箱和拆箱操作发生在引用类型和值类型之间
     *
     * 重载（Overload）：
     *      发生在同一个类中的两个或多个方法名相同但是参数不同的情况（返回类型也可以不同）
     * 覆盖（Override）：
     *      子类重新定义父类的方法，方法名、返回类型、参数都必须相同。
     *      子类中覆盖的方法的权限必须大于等于父类的方法(包括抽象方法)
     *
     * 垃圾回收的目的：
     *      识别并丢弃应用中不再使用的对象来释放和重用资源
     *
     * 垃圾回收：
     *      当对像的所有引用都被置为空的时候，在下一个垃圾回收周期中，对象才被回收
     *      垃圾回收器在准备释放内存的时候，会先调用finalize()
     *
     * 不同对象应用类型，GC采用不同方法进行回收：
     *      强引用：默认情况下对象的引用均为强引用（对象的实例没有被其他对象应用，GC时才会被回收）
     *      软引用：在内存不够用的情况下才会被GC
     *      弱引用：在GC是一定会被GC回收
     *      虚引用：用来得知对象是否被GC
     *
     */
    /**
     * 程序计数器PC：
     *      当前指令或操作码的地址（本地指令除外），如果当前方法是native方法，PC为undefined
     *      所有的CPU都有一个PC，PC存储了要被执行的下一条指令的地址
     *
     * 堆区：（每个线程都拥有自己的栈）
     *      1、存储的全部是对象（实例），每个对象都包含一个与之对应的class信息（数组）
     *      2、jvm只有一个堆区被所有线程共享，堆区不存放基本类型和对象引用，只存放对象本身
     *      3、一般由程序员分配释放，若程序员未释放，程序结束时可由OS回收
     *
     * 栈区：
     *      1、每个线程包含一个栈区，只保存基础数据类型的对象和自定义的对象的引用
     *      2、每个栈中数据都是私有的，其他栈不能访问
     *      3、栈分为三部分：基本类型变量区、执行环境上下文、操作指令区（存放操作指令）
     *      4、由编译器自动分配释放，存放函数的参数值和局部变量的值等
     *
     * 静态区/方法区
     *      1、方法区又叫静态区，被所有线程共享，存储所有的class和static变量、final类型的常量、
     *          类中方法信息、类中域的信息。
     *      2、方法区中存储的都是整个程序中永远唯一的元素，如class、static变量
     *      3、全局变量和静态变量的存储是放在一块的：
     *          初始化的全局变量和初始化的静态变量在一块区域
     *          未初始化的全局变量和未初始化的静态变量在一块区域
     * 运行时常量池：
     *      类中固定常量信息、方法和域的引用信息，其空间从方法区中分配
     *
     * 本地方法栈：
     *      JVM采用本地方法堆栈的方式来支持native方法的执行，用于存储native方法的调用状态
     */

    /**
     * 类变量：也叫静态变量，是类中独立于方法之外的变量，用static修饰
     *
     * 实例变量：也叫成员变量，也是类中独立与方法之外的变量，不过没有用static修饰
     *
     * 局部变量：类中方法中定义的变量
     */

    /**
     * Static：
     *      表示“全局的”、“静态的”，用来修饰成员变量和成员方法，
     *      表示成员变量和成员方法可以在没有所属的类的实例的情况下被访问
     *      static方法不能被覆盖
     *      或静态代码块（静态代码块独立于类成员，jvm加载类时会执行静态代码块，
     *      每个代码块只执行一次，按顺序执行））
     */

    /**
     * Java的内存管理实际上就是对对象的管理，其中包括对象的分配和释放
     *
     * 分配对象：
     *      使用new关键字
     *
     * 释放对象：
     *      将对象所有引用赋值为null，让程序不能再访问到这个对象，我们称该对象是不可到达的，
     *      GC将负责回收所有不可到达的对象的内存
     *
     *      对于GC来说，当对象被创建时，GC就开始监控这个对象的地址、大小以及使用情况
     *      通常，GC是采用有向图的方式记录和管理堆中的所有对象
     *
     * 增量式GC：
     *      在JVM中通常由一个或一组进程来实现，其本身和应用程序一样占用heap空间，运行时也占用CPU，
     *      当GC进程运行时，应用程序停止运行
     *
     */

    /**
     * 什么是Java虚拟机：
     *      一个可以执行Java字节码的虚拟机进程
     *
     * 虚拟机中没有泛型，只有普通类和普通方法，所有泛型的类型参数都会在编译时被擦除
     * 创建泛型对象时请指明类型，让编译器尽早做类型检查
     *
     * JDK与JRE的区别：
     *      JDK：Java开发工具包，包含了JRE、编译器和其他工具（JavaDoc ， Java调试器）
     *      JRE：Java运行环境，包含Java虚拟机和java程序所需的核心类库
     *      如果执行跑Java程序只需要JRE，如果需要写Java程序并运行需要JDK
     *
     * Static：
     *      static方法编译时是静态绑定的，属于类，而覆盖属于运行时动态绑定，因此static方法不能被覆盖
     *
     * 两个基本的垃圾回收算法：
     *      复制算法 、 标记清除算法
     *
     * 新生代：
     *      初始对象 ， 生命周期短的
     *
     * 永久代：
     *      长时间存在的对象
     *
     * 新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。
     *
     *
     * 运行时常量池：
     *      是方法区的一部分，用于存储编译器生成的各种字面量和符号引用
     *
     * 直接内存：
     */


}
